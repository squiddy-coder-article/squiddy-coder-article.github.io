<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebRTC: Chat + Camera + Screen + Remote Control (No Server)</title>
  <style>
    :root { --bg:#0f1220; --panel:#1a1f35; --muted:#2a3053; --text:#e9ecff; --accent:#6ea8fe; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text); }
    header { padding:16px; border-bottom:1px solid var(--muted); }
    main { display:grid; grid-template-columns: 380px 1fr; gap:0; height: calc(100vh - 64px); }
    aside { background:var(--panel); padding:14px; overflow:auto; border-right:1px solid var(--muted); }
    section { padding:14px; overflow:auto; }
    h2 { margin:10px 0 8px; font-size:16px; }
    textarea, input { width:100%; box-sizing:border-box; padding:8px; border-radius:8px; border:1px solid var(--muted); background:#0d1122; color:var(--text); }
    textarea { min-height:96px; }
    button { background:var(--accent); color:#0c1328; border:0; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .row { display:flex; gap:8px; margin:8px 0; flex-wrap:wrap; }
    .stack { display:grid; gap:8px; }
    .panel { border:1px solid var(--muted); border-radius:10px; padding:10px; background:#121635; }
    video { width: 320px; height: 180px; background:#000; border-radius:8px; border:1px solid var(--muted); }
    #videos { display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start; }
    #chatLog { height:160px; overflow:auto; border:1px solid var(--muted); border-radius:8px; padding:8px; background:#0d1122; }
    #screenArea { margin-top:12px; }
    #screenCanvas { width: 960px; height: 540px; background:#0b0f21; border:1px dashed var(--muted); border-radius:8px; position:relative; }
    #cursor { position:absolute; width:14px; height:14px; background:#fff; border-radius:50%; box-shadow:0 0 0 2px #222; transform:translate(-50%, -50%); pointer-events:none; opacity:.9; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; background:#0d1122; border:1px solid var(--muted); font-size:12px; }
    .small { font-size:12px; opacity:.8; }
    .notice { background:#0d1122; border-left:4px solid var(--accent); padding:8px; border-radius:6px; }
  </style>
</head>
<body>
  <header>
    <div class="row" style="justify-content:space-between; align-items:center;">
      <div><strong>WebRTC demo</strong> — Chat, Camera, Screen Share, Remote Control</div>
      <div class="badge">No server required (manual SDP copy/paste)</div>
    </div>
  </header>

  <main>
    <aside>
      <h2>Signaling (manual)</h2>
      <div class="panel stack">
        <div class="row">
          <button id="createOfferBtn">Create offer</button>
          <button id="createAnswerBtn" disabled>Create answer</button>
        </div>
        <label class="small">Local SDP (copy this to peer)</label>
        <textarea id="localSdp" placeholder="Generated SDP appears here"></textarea>
        <div class="row">
          <button id="copyLocalBtn">Copy local SDP</button>
        </div>
        <label class="small">Remote SDP (paste here)</label>
        <textarea id="remoteSdp" placeholder="Paste peer's SDP here"></textarea>
        <div class="row">
          <button id="setRemoteBtn">Set remote</button>
        </div>
        <div class="notice small">
          Steps:
          <ol style="margin:6px 0 0 18px;">
            <li>Peer A clicks “Create offer”, copies Local SDP, sends to Peer B.</li>
            <li>Peer B pastes into Remote, clicks “Set remote”, then “Create answer”.</li>
            <li>Peer B copies Local SDP (answer) back to A. A pastes into Remote and “Set remote”.</li>
          </ol>
        </div>
      </div>

      <h2>Media</h2>
      <div class="panel stack">
        <div class="row">
          <button id="startCamBtn" disabled>Start camera</button>
          <button id="shareScreenBtn" disabled>Share screen</button>
          <button id="stopMediaBtn" disabled>Stop media</button>
        </div>
        <div class="small">Tip: You can toggle between camera and screen by replacing the video track.</div>
      </div>

      <h2>Remote control</h2>
      <div class="panel stack">
        <div class="row">
          <button id="grantControlBtn" disabled>Grant control</button>
          <button id="revokeControlBtn" disabled>Revoke control</button>
        </div>
        <div class="small">When granted, the peer’s mouse/keyboard in the preview area will control interactive elements on your page.</div>
      </div>

      <h2>Chat</h2>
      <div class="panel stack">
        <div id="chatLog"></div>
        <div class="row">
          <input id="chatInput" placeholder="Type message…">
          <button id="sendBtn" disabled>Send</button>
        </div>
      </div>

      <h2>Status</h2>
      <div class="panel">
        <div id="status" class="small">Idle</div>
      </div>
    </aside>

    <section>
      <div id="videos">
        <div>
          <div class="small">Local</div>
          <video id="localVideo" autoplay playsinline muted></video>
        </div>
        <div>
          <div class="small">Remote</div>
          <video id="remoteVideo" autoplay playsinline></video>
        </div>
      </div>

      <div id="screenArea">
        <div class="small">Remote control preview area (controls target this page)</div>
        <div id="screenCanvas">
          <div id="cursor" hidden></div>
        </div>
      </div>
    </section>
  </main>

  <script>
    // Elements
    const createOfferBtn = document.getElementById('createOfferBtn');
    const createAnswerBtn = document.getElementById('createAnswerBtn');
    const localSdpEl = document.getElementById('localSdp');
    const remoteSdpEl = document.getElementById('remoteSdp');
    const setRemoteBtn = document.getElementById('setRemoteBtn');
    const copyLocalBtn = document.getElementById('copyLocalBtn');

    const startCamBtn = document.getElementById('startCamBtn');
    const shareScreenBtn = document.getElementById('shareScreenBtn');
    const stopMediaBtn = document.getElementById('stopMediaBtn');

    const grantControlBtn = document.getElementById('grantControlBtn');
    const revokeControlBtn = document.getElementById('revokeControlBtn');

    const sendBtn = document.getElementById('sendBtn');
    const chatInput = document.getElementById('chatInput');
    const chatLog = document.getElementById('chatLog');

    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const statusEl = document.getElementById('status');

    const screenCanvas = document.getElementById('screenCanvas');
    const cursorEl = document.getElementById('cursor');

    // State
    const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
    let pc;
    let chatChannel;
    let controlChannel;
    let localStream;
    let remoteControlGranted = false;
    let isOfferer = false;
    let isAnswerer = false;

    function setStatus(s) { statusEl.textContent = s; }

    function initPeer() {
      if (pc) return;
      pc = new RTCPeerConnection(rtcConfig);

      // As offerer, pre-create data channels
      pc.onnegotiationneeded = async () => {
        // handled by manual buttons
      };

      chatChannel = pc.createDataChannel('chat');
      chatChannel.onopen = () => sendBtn.disabled = false;
      chatChannel.onmessage = (e) => appendChat('Peer', e.data);

      controlChannel = pc.createDataChannel('control');
      controlChannel.onmessage = (e) => {
        const data = JSON.parse(e.data);
        if (!remoteControlGranted) return;
        applyRemoteControlEvent(data);
      };

      pc.ondatachannel = (ev) => {
        const ch = ev.channel;
        if (ch.label === 'chat') {
          chatChannel = ch;
          chatChannel.onopen = () => sendBtn.disabled = false;
          chatChannel.onmessage = (e) => appendChat('Peer', e.data);
        }
        if (ch.label === 'control') {
          controlChannel = ch;
          controlChannel.onmessage = (e) => {
            const data = JSON.parse(e.data);
            if (!remoteControlGranted) return;
            applyRemoteControlEvent(data);
          };
        }
      };

      pc.onicecandidate = (e) => {
        // In manual signaling, we rely on trickle disabled flow:
        // We'll include candidates once gathering is complete via SDP.
        // So do nothing here.
      };

      pc.onicegatheringstatechange = () => {
        if (pc.iceGatheringState === 'complete') {
          localSdpEl.value = pc.localDescription.sdp;
        }
      };

      pc.ontrack = (evt) => {
        if (remoteVideo.srcObject !== evt.streams[0]) {
          remoteVideo.srcObject = evt.streams[0];
        }
      };

      startCamBtn.disabled = false;
      shareScreenBtn.disabled = false;
      stopMediaBtn.disabled = false;
      grantControlBtn.disabled = false;
      revokeControlBtn.disabled = true;

      setStatus('Peer ready');
    }

    // Chat
    function appendChat(who, text) {
      const div = document.createElement('div');
      div.textContent = `${who}: ${text}`;
      chatLog.appendChild(div);
      chatLog.scrollTop = chatLog.scrollHeight;
    }
    sendBtn.onclick = () => {
      const msg = chatInput.value.trim();
      if (!msg || !chatChannel || chatChannel.readyState !== 'open') return;
      chatChannel.send(msg);
      appendChat('You', msg);
      chatInput.value = '';
    };

    // Media controls
    startCamBtn.onclick = async () => {
      initPeer();
      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      localStream = stream;
      localVideo.srcObject = stream;
      for (const track of stream.getTracks()) pc.addTrack(track, stream);
      setStatus('Camera started');
    };

    shareScreenBtn.onclick = async () => {
      initPeer();
      const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
      const track = screenStream.getVideoTracks()[0];
      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
      if (sender) {
        await sender.replaceTrack(track);
      } else {
        pc.addTrack(track, screenStream);
      }
      localVideo.srcObject = screenStream;
      setStatus('Screen sharing');
      track.onended = () => setStatus('Screen share ended');
    };

    stopMediaBtn.onclick = () => {
      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
        localVideo.srcObject = null;
        setStatus('Media stopped');
      }
    };

    // Control grant/revoke
    grantControlBtn.onclick = () => {
      remoteControlGranted = true;
      grantControlBtn.disabled = true;
      revokeControlBtn.disabled = false;
      setStatus('Control granted');
    };
    revokeControlBtn.onclick = () => {
      remoteControlGranted = false;
      grantControlBtn.disabled = false;
      revokeControlBtn.disabled = true;
      setStatus('Control revoked');
    };

    // Send control events from controller side
    screenCanvas.addEventListener('mousemove', (e) => sendControlEvent('mousemove', e));
    screenCanvas.addEventListener('mousedown', (e) => sendControlEvent('mousedown', e));
    screenCanvas.addEventListener('mouseup',   (e) => sendControlEvent('mouseup', e));
    window.addEventListener('keydown', (e) => sendControlEvent('keydown', e));
    window.addEventListener('keyup',   (e) => sendControlEvent('keyup', e));

    function sendControlEvent(type, e) {
      if (!controlChannel || controlChannel.readyState !== 'open') return;
      const rect = screenCanvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width;
      const y = (e.clientY - rect.top) / rect.height;
      const payload = {
        type, x, y,
        button: e.button ?? 0,
        key: e.key ?? '',
        ctrl: !!e.ctrlKey, alt: !!e.altKey, shift: !!e.shiftKey, meta: !!e.metaKey
      };
      controlChannel.send(JSON.stringify(payload));
    }

    // Apply remote events on receiver side (DOM-level)
    function applyRemoteControlEvent(ev) {
      if (ev.type === 'mousemove') {
        cursorEl.hidden = false;
        const rect = screenCanvas.getBoundingClientRect();
        cursorEl.style.left = (ev.x * rect.width) + 'px';
        cursorEl.style.top  = (ev.y * rect.height) + 'px';
        return;
      }
      if (ev.type === 'mousedown' || ev.type === 'mouseup') {
        const target = elementAtNormalized(ev.x, ev.y);
        if (target) {
          const event = new MouseEvent(ev.type, { bubbles: true, button: ev.button });
          target.dispatchEvent(event);
        }
        return;
      }
      if (ev.type === 'keydown' || ev.type === 'keyup') {
        const focused = document.activeElement || document.body;
        const event = new KeyboardEvent(ev.type, {
          bubbles: true, key: ev.key,
          ctrlKey: ev.ctrl, altKey: ev.alt, shiftKey: ev.shift, metaKey: ev.meta
        });
        focused.dispatchEvent(event);
        return;
      }
    }

    function elementAtNormalized(nx, ny) {
      const rect = screenCanvas.getBoundingClientRect();
      const x = nx * rect.width + rect.left;
      const y = ny * rect.height + rect.top;
      return document.elementFromPoint(x, y);
    }

    // Manual signaling: disable trickle ICE for simplicity
    async function createOffer() {
      initPeer();
      isOfferer = true;
      await pc.setLocalDescription(await pc.createOffer({ iceRestart: true }));
      await waitIceComplete();
      localSdpEl.value = pc.localDescription.sdp;
      createAnswerBtn.disabled = true;
      setStatus('Offer created. Copy SDP to peer.');
    }

    async function setRemoteOfferThenAnswer() {
      initPeer();
      const sdp = remoteSdpEl.value.trim();
      if (!sdp) return alert('Paste remote SDP offer first');
      await pc.setRemoteDescription({ type: 'offer', sdp });
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      await waitIceComplete();
      localSdpEl.value = pc.localDescription.sdp;
      isAnswerer = true;
      setStatus('Answer created. Send SDP back to offerer.');
    }

    async function setRemoteAnswer() {
      const sdp = remoteSdpEl.value.trim();
      if (!sdp) return alert('Paste remote SDP answer first');
      await pc.setRemoteDescription({ type: 'answer', sdp });
      setStatus('Remote answer set. Connection should establish shortly.');
    }

    function waitIceComplete() {
      return new Promise(resolve => {
        if (!pc) return resolve();
        if (pc.iceGatheringState === 'complete') return resolve();
        pc.addEventListener('icegatheringstatechange', () => {
          if (pc.iceGatheringState === 'complete') resolve();
        });
      });
    }

    // Buttons wiring
    createOfferBtn.onclick = () => {
      createOffer();
      createAnswerBtn.disabled = true;
      startCamBtn.disabled = false;
      shareScreenBtn.disabled = false;
      stopMediaBtn.disabled = false;
      grantControlBtn.disabled = false;
    };

    createAnswerBtn.onclick = () => {
      setRemoteOfferThenAnswer();
      startCamBtn.disabled = false;
      shareScreenBtn.disabled = false;
      stopMediaBtn.disabled = false;
      grantControlBtn.disabled = false;
    };

    setRemoteBtn.onclick = async () => {
      // Decide whether we're setting an offer or an answer
      const sdp = remoteSdpEl.value.trim();
      if (!sdp) return alert('Paste remote SDP first');
      if (!pc || (pc.localDescription && pc.localDescription.type === 'answer')) {
        // We're the offerer setting the remote answer
        await setRemoteAnswer();
      } else {
        // We're the answerer setting the remote offer before creating answer
        await pc.setRemoteDescription({ type: 'offer', sdp });
        setStatus('Remote offer set. Click "Create answer".');
        createAnswerBtn.disabled = false;
      }
    };

    copyLocalBtn.onclick = async () => {
      const txt = localSdpEl.value.trim();
      if (!txt) return;
      try {
        await navigator.clipboard.writeText(txt);
        copyLocalBtn.textContent = 'Copied!';
        setTimeout(() => (copyLocalBtn.textContent = 'Copy local SDP'), 1000);
      } catch {
        // ignore
      }
    };
  </script>
</body>
</html>
